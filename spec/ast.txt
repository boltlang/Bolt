
@language Bolt;
@language JS;

node EndOfFile > BoltToken, JSToken;

// Bolt language AST definitions

type BoltValue = Integer | bool | String;

node FunctionBody;

node BoltToken;

node BoltStringLiteral > BoltToken {
  value: String,
}

node BoltIntegerLiteral > BoltToken {
  value: Int,
}

node BoltSymbol > BoltToken {
  
}

node BoltIdentifier > BoltSymbol {
  text: String,
}

node BoltOperator > BoltSymbol {
  text: String,
}

node BoltAssignment > BoltToken {
  operator: Option<String>,
}

node BoltComma  > BoltToken;
node BoltSemi   > BoltToken;
node BoltColon  > BoltToken;
node BoltDot    > BoltToken;
node BoltDotDot > BoltToken;
node BoltRArrow > BoltToken;
node BoltLArrow > BoltToken;
node BoltEqSign > BoltToken;
node BoltGtSign > BoltToken;
node BoltLtSign > BoltToken;

node BoltKeyword;

node BoltFnKeyword      > BoltToken, BoltKeyword;
node BoltForeignKeyword > BoltToken, BoltKeyword;
node BoltLetKeyword     > BoltToken, BoltKeyword;
node BoltReturnKeyword  > BoltToken, BoltKeyword;
node BoltLoopKeyword    > BoltToken, BoltKeyword;
node BoltYieldKeyword   > BoltToken, BoltKeyword;
node BoltMatchKeyword   > BoltToken, BoltKeyword;
node BoltImportKeyword  > BoltToken, BoltKeyword;
node BoltPubKeyword     > BoltToken, BoltKeyword;
node BoltModKeyword     > BoltToken, BoltKeyword;
node BoltMutKeyword     > BoltToken, BoltKeyword;
node BoltEnumKeyword    > BoltToken, BoltKeyword;
node BoltStructKeyword  > BoltToken, BoltKeyword;
node BoltTypeKeyword    > BoltToken, BoltKeyword;
node BoltTraitKeyworkd  > BoltToken, BoltKeyword;

node BoltPunctuated > BoltToken {
  text: String,
}

node BoltParenthesized > BoltPunctuated;
node BoltBraced > BoltPunctuated;
node BoltBracketed > BoltPunctuated;

node BoltSourceFile {
  elements: Vec<BoltSourceElement>,
}

node BoltQualName {
  modulePath: Vec<BoltIdentifier>,
  name: BoltSymbol, 
}

node BoltSentence > BoltSourceElement {
  tokens: Vec<BoltToken>,
}

node BoltTypeExpression;

node BoltReferenceTypeExpression > BoltTypeExpression {
  name: BoltQualName,
  arguments: Option<Vec<BoltTypeExpression>>,
}

node BoltTypeParameter {
  index: usize,
  name: BoltIdentifier,
  defaultType: Option<BoltTypeExpression>,
}

node BoltPattern;

node BoltBindPattern > BoltPattern {
  name: BoltIdentifier,
}

node BoltTypePattern > BoltPattern {
  type: BoltTypeExpression,
  nestedPattern: BoltPattern,
}

node BoltExpressionPattern > BoltPattern {
  expression: BoltExpression,
}

node BoltTuplePatternElement {
  index: usize,
  pattern: BoltPattern,
}

node BoltTuplePattern > BoltPattern {
  elements: Vec<BoltTuplePatternElement>,
}

node BoltRecordPatternField {
  name: BoltIdentifier,
  pattern: BoltPattern,
}

node BoltRecordPattern > BoltPattern {
  name: BoltTypeExpression,
  fields: Vec<BoltRecordPatternField>,
}

node BoltExpression;

node BoltReferenceExpression > BoltExpression {
  name: BoltQualName,
}

node BoltCallExpression > BoltExpression {
  operator: BoltExpression,
  operands: Vec<BoltExpression>,
}

node BoltYieldExpression > BoltExpression {
  value: BoltExpression,
}

node BoltMatchArm {
  pattern: BoltPattern,
  body: BoltExpression,
}

node BoltMatchExpression > BoltExpression {
  value: BoltExpression,
  arms: Vec<BoltMatchArm>,
}

node BoltCase {
  test: BoltExpression,
  result: BoltExpression,
}

node BoltCaseExpression > BoltExpression {
  cases: Vec<BoltCase>,
}

node BoltBlockExpression > BoltExpression {
  statements: Vec<BoltStatement>,
}

node BoltConstantExpression > BoltExpression {
  value: BoltValue,
}

node BoltStatement > BoltSourceElement;

node BoltReturnStatement > BoltStatement {
  value: Option<BoltExpression>,
}

node BoltResumeStatement > BoltStatement {
  value: BoltExpression,
}

node BoltExpressionStatement > BoltStatement {
  expression: BoltExpression,
}

node BoltParameter {
  index: usize,
  bindings: BoltPattern,
  type: Option<BoltTypeExpression>,
  defaultValue: Option<BoltExpression>,
}

node BoltDeclaration > BoltSourceElement;

node BoltTypeDeclaration > BoltDeclaration;

enum BoltDeclarationModifiers {
  Mutable   = 0x1,
  Public    = 0x2,
  IsType    = 0x4,
  IsForeign = 0x8,
}


node BoltModule > BoltDeclaration {
  modifiers: BoltDeclarationModifiers,
  name: BoltQualName,
  elements: Vec<BoltSourceElement>,
}

node BoltFunctionDeclaration > BoltDeclaration {
  modifiers: BoltDeclarationModifiers,
  target: String,
  name: BoltSymbol,
  params: Vec<BoltParameter>,
  returnType: Option<BoltTypeExpression>,
  body: Vec<BoltStatement>,
}

node BoltVariableDeclaration > BoltDeclaration {
  modifiers: BoltDeclarationModifiers,
  bindings: BoltPattern,
  type: Option<BoltTypeExpression>,
  value: Option<BoltExpression>,
}

node BoltImportSymbol;

node BoltPlainImportSymbol > BoltImportSymbol {
  name: BoltQualName,
}

node BoltImportDeclaration > BoltDeclaration {
  file: String,
  symbols: Vec<BoltImportSymbol>,
}

node BoltRecordDeclarationField {
  name: BoltIdentifier,
  type: BoltTypeExpression,
}

node BoltTypeAliasDeclaration > BoltTypeDeclaration {
  modifiers: BoltDeclarationModifiers,
  name: BoltIdentifier,
  typeParams: Option<Vec<BoltTypeParameter>>,
  typeExpr: BoltTypeExpression,
}

node BoltSourceElement;

node BoltRecordDeclaration > BoltTypeDeclaration {
  modifiers: BoltDeclarationModifiers,
  name: BoltQualName,
  typeParms: Option<Vec<BoltTypeParameter>>,
  fields: Vec<BoltRecordDeclarationField>,
}

// JavaScript AST definitions

type JSValue = Int | String | Bool | Void;

node JSToken;

node JSOperator > JSToken {
  text: String,
}

node JSIdentifier > JSToken {
  text: String,
}

node JSReturnKeyword > JSToken;
node JSTryKeyword > JSToken;
node JSCatchKeyword > JSToken;

node JSPattern;

node JSBindPattern > JSPattern {
  name: JSIdentifier,
}

node JSExpression;

node JSConstantExpression > JSExpression {
  value: BoltValue,
}

enum JSMemberExpressionModifiers {
  Computed = 0x1,
}

node JSMemberExpression > JSExpression {
  value: JSExpression,
  property: JSExpression,
  modifiers: JSMemberExpressionModifiers,
}

node JSCallExpression > JSExpression {
  operator: JSExpression,
  operands: Vec<JSExpression>,
}

node JSBinaryExpression > JSExpression {
  left: JSExpression,
  operator: JSOperator,
  right: JSExpression,
}

node JSUnaryExpression > JSExpression {
  operator: JSOperator,
  operand: JSExpression
}

node JSNewExpression > JSExpression {
  target: JSExpression,
  arguments: Vec<JSExpression>,
}

node JSSequenceExpression > JSExpression {
  expressions: Vec<JSExpression>,
}

node JSConditionalExpression > JSExpression {
  test: JSExpression,
  consequent: JSExpression,
  alternate: JSExpression,
}

node JSReferenceExpression > JSExpression {
  name: String,
}

node JSSourceElement;

node JSStatement > JSSourceElement;

node JSExpressionStatement > JSStatement {
  expression: JSExpression,
}

node JSConditionalStatement > JSStatement {
  test: JSExpression,
  consequent: Vec<JSStatement>,
  alternate: Vec<JSStatement>,
}

node JSParameter {
  index: usize,
  bindings: JSPattern,
  defaultValue: Option<JSExpression>,
}

node JSDeclaration > JSSourceElement;

enum JSDeclarationModifiers {
  IsExported = 0x1,
}

node JSFunctionDeclaration > JSDeclaration {
  modifiers: JSDeclarationModifiers,
  name: JSIdentifier,
  params: Vec<JSParameter>,
  body: Vec<JSStatement>,
}

node JSArrowFunctionDeclaration > JSDeclaration {
  name: JSIdentifier,
  params: Vec<JSParameter>,
  body: JSExpression,
}

node JSLetDeclaration > JSDeclaration {
  bindings: JSPattern,
  value: Option<JSExpression>,
}

node JSSourceFile {
  elements: Vec<JSSourceElement>,
}

