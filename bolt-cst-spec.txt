
#include <vector>
#include <optional>

#include "bolt/Text.hpp"
#include "bolt/Integer.hpp"
#include "bolt/ByteString.hpp"

external Integer;
external ByteString;
external TextRange;

// Tokens

node Token {
  TextLoc start_loc;
}

node Equals : Token {}
node Colon : Token {}
node Dot : Token {}
node LParen : Token {}
node RParen : Token {}
node LBracket : Token {}
node RBracket : Token {}
node LBrace : Token {}
node RBrace : Token {}

node LetKeyword : Token {}
node MutKeyword : Token {}
node PubKeyword : Token {}
node TypeKeyword : Token {}
node ReturnKeyword : Token {}
node ModKeyword : Token {}
node StructKeyword : Token {}

node Invalid : Token {}

node EndOfFile : Token {}
node BlockStart : Token {}
node BlockEnd : Token {}
node LineFoldEnd : Token {}

node CustomOperator : Token {
  ByteString text;
}

node Identifier : Token {
  ByteString text;
}

node StringLiteral : Token {
  ByteString text;
}

node IntegerLiteral : Token {
  Integer value;
}

node QualifiedName {
  List<Identifier> module_path;
  Identifier name;
}

node SourceElement {}

node LetBodyElement {}

// Type expressions 

node TypeExpression {}

node ReferenceTypeExpression : TypeExpression {
  QualifiedName name;
}

// Patterns

node Pattern {}

node BindPattern : Pattern {
  Identifier name;
}

// Expresssions

node Expression {}

node ReferenceExpression : Expression {
  Identifier name;
}

node ConstantExpression : Expression {
  Variant<StringLiteral, IntegerLiteral> token;
}

node CallExpression : Expression {
  Expression function;
  List<Expression> args;
}

// Statements

node Statement : LetBodyElement {}

node ExpressionStatement : Statement, SourceElement {
  Expression expression;
}

node ReturnStatement : Statement {
  ReturnKeyword return_keyword;
  Expression expression;
}

// Other nodes

node TypeAssert {
  Colon colon;
  TypeExpression type_expression;
}

node Param {
  Pattern pattern;
  TypeAssert type_assert;
}

// Declarations

node LetBody {}

node LetBlockBody : LetBody {
  BlockStart block_start;
  List<LetBodyElement> elements;
}

node LetExprBody : LetBody {
  Equals equals;
  Expression expression;
}

node LetDeclaration : SourceElement, LetBodyElement {
  Option<PubKeyword> pub_keyword;
  LetKeyword let_keywod;
  Option<MutKeyword> mut_keyword;
  Pattern pattern;
  List<Param> params;
  Option<TypeAssert> type_assert;
  Option<LetBody> body;
}

node StructDeclField {
  Identifier name;
  Colon colon;
  TypeExpression type_expression;
}

node StructDecl : SourceElement {
  StructKeyword struct_keyword;
  Identifier name;
  Dot dot;
  List<StructDeclField> fields;
}

node SourceFile {
  List<SourceElement> elements;
}

