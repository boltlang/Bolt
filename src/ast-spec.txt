
@language Bolt;
@language JS;

node EndOfFile > BoltToken, JSToken;
node Token;
node SourceFile;

// Bolt language AST definitions

type BoltValue = Integer | bool | String;

node FunctionBody;

node BoltToken > Token;

node BoltStringLiteral > BoltToken {
  value: String,
}

node BoltIntegerLiteral > BoltToken {
  value: Int,
}

node BoltSymbol > BoltToken;

node BoltIdentifier > BoltSymbol {
  text: String,
}

node BoltOperatorLike > BoltSymbol;

node BoltOperator > BoltSymbol {
  text: String,
}

node BoltAssignment > BoltToken {
  operator: Option<String>,
}

node BoltComma      > BoltToken;
node BoltSemi       > BoltToken;
node BoltColon      > BoltToken;
node BoltColonColon > BoltToken;
node BoltDot        > BoltToken;
node BoltDotDot     > BoltToken;
node BoltRArrow     > BoltToken;
node BoltRArrowAlt  > BoltToken;
node BoltLArrow     > BoltToken;
node BoltEqSign     > BoltToken;

node BoltGtSign    > BoltToken, BoltOperatorLike;
node BoltExMark    > BoltToken, BoltOperatorLike;
node BoltLtSign    > BoltToken, BoltOperatorLike;
node BoltVBar      > BoltToken, BoltOperatorLike;

node BoltKeyword;

node BoltWhereKeyword   > BoltToken, BoltKeyword;
node BoltQuoteKeyword   > BoltToken, BoltKeyword;
node BoltFnKeyword      > BoltToken, BoltKeyword;
node BoltForeignKeyword > BoltToken, BoltKeyword;
node BoltForKeyword     > BoltToken, BoltKeyword;
node BoltLetKeyword     > BoltToken, BoltKeyword;
node BoltReturnKeyword  > BoltToken, BoltKeyword;
node BoltLoopKeyword    > BoltToken, BoltKeyword;
node BoltYieldKeyword   > BoltToken, BoltKeyword;
node BoltMatchKeyword   > BoltToken, BoltKeyword;
node BoltImportKeyword  > BoltToken, BoltKeyword;
node BoltExportKeyword  > BoltToken, BoltKeyword;
node BoltPubKeyword     > BoltToken, BoltKeyword;
node BoltModKeyword     > BoltToken, BoltKeyword;
node BoltMutKeyword     > BoltToken, BoltKeyword;
node BoltEnumKeyword    > BoltToken, BoltKeyword;
node BoltStructKeyword  > BoltToken, BoltKeyword;
node BoltTypeKeyword    > BoltToken, BoltKeyword;
node BoltTraitKeyword   > BoltToken, BoltKeyword;
node BoltImplKeyword    > BoltToken, BoltKeyword;

node BoltPunctuated > BoltToken {
  text: String,
}

node BoltParenthesized > BoltPunctuated;
node BoltBraced > BoltPunctuated;
node BoltBracketed > BoltPunctuated;

node BoltSourceFile > SourceFile {
  elements: Vec<BoltSourceElement>,
  package: Package,
}

node BoltQualName {
  modulePath: Option<Vec<BoltIdentifier>>,
  name: BoltSymbol, 
}

node BoltTypeExpression;

node BoltReferenceTypeExpression > BoltTypeExpression {
  name: BoltQualName,
  arguments: Option<Vec<BoltTypeExpression>>,
}

node BoltFunctionTypeExpression > BoltTypeExpression {
  params: Vec<BoltParameter>,
  returnType: Option<BoltTypeExpression>,
}

node BoltTypeParameter {
  index: usize,
  name: BoltIdentifier,
  defaultType: Option<BoltTypeExpression>,
}

node BoltPattern;

node BoltBindPattern > BoltPattern {
  name: BoltIdentifier,
}

node BoltTypePattern > BoltPattern {
  type: BoltTypeExpression,
  nestedPattern: BoltPattern,
}

node BoltExpressionPattern > BoltPattern {
  expression: BoltExpression,
}

node BoltTuplePatternElement {
  index: usize,
  pattern: BoltPattern,
}

node BoltTuplePattern > BoltPattern {
  elements: Vec<BoltTuplePatternElement>,
}

node BoltRecordFieldPattern {
  isRest: bool,
  name: Option<BoltIdentifier>,
  pattern: Option<BoltPattern>,
}

node BoltRecordPattern > BoltPattern {
  name: BoltQualName,
  fields: Vec<BoltRecordFieldPattern>,
}

node BoltExpression;

node BoltQuoteExpression > BoltExpression {
  tokens: Vec<Token>,
}

node BoltReferenceExpression > BoltExpression {
  name: BoltQualName,
}

node BoltMemberExpression > BoltExpression {
  expression: BoltExpression,
  path: Vec<BoltIdentifier>,
}

node BoltFunctionExpression > BoltExpression {
  params: Vec<BoltParameter>,
  returnType: Option<BoltTypeExpression>,
  body: Vec<BoltFunctionBodyElement>,
}

node BoltCallExpression > BoltExpression {
  operator: BoltExpression,
  operands: Vec<BoltExpression>,
}

node BoltYieldExpression > BoltExpression {
  value: BoltExpression,
}

node BoltMatchArm {
  pattern: BoltPattern,
  body: BoltExpression,
}

node BoltMatchExpression > BoltExpression {
  value: BoltExpression,
  arms: Vec<BoltMatchArm>,
}

node BoltCase {
  test: BoltExpression,
  result: BoltExpression,
}

node BoltCaseExpression > BoltExpression {
  cases: Vec<BoltCase>,
}

node BoltBlockExpression > BoltExpression {
  elements: Vec<BoltFunctionBodyElement>,
}

node BoltConstantExpression > BoltExpression {
  value: BoltValue,
}

node BoltStatement > BoltFunctionBodyElement, BoltSourceElement;

node BoltReturnStatement > BoltStatement {
  value: Option<BoltExpression>,
}

node BoltConditionalCase {
  test: Option<BoltExpression>,
  body: Vec<BoltFunctionBodyElement>,
}

node BoltConditionalStatement > BoltStatement {
  cases: Vec<BoltConditionalCase>,
}

node BoltResumeStatement > BoltStatement {
  value: BoltExpression,
}

node BoltExpressionStatement > BoltStatement {
  expression: BoltExpression,
}

node BoltParameter {
  index: usize,
  bindings: BoltPattern,
  type: Option<BoltTypeExpression>,
  defaultValue: Option<BoltExpression>,
}

node BoltDeclaration > BoltSourceElement;

node BoltTypeDeclaration > BoltSourceElement;

enum BoltModifiers {
  IsMutable   = 0x1,
  IsPublic    = 0x2,
}

node BoltModule > BoltSourceElement {
  modifiers: BoltModifiers,
  name: BoltQualName,
  elements: Vec<BoltSourceElement>,
}

node BoltFunctionBodyElement;

node BoltFunctionDeclaration > BoltFunctionBodyElement, BoltDeclaration {
  modifiers: BoltModifiers,
  target: String,
  name: BoltSymbol,
  params: Vec<BoltParameter>,
  returnType: Option<BoltTypeExpression>,
  typeParams: Option<Vec<BoltTypeParameter>>,
  body: Vec<BoltFunctionBodyElement>,
}

node BoltVariableDeclaration > BoltFunctionBodyElement, BoltDeclaration {
  modifiers: BoltModifiers,
  bindings: BoltPattern,
  type: Option<BoltTypeExpression>,
  value: Option<BoltExpression>,
}

node BoltImportSymbol;

node BoltPlainImportSymbol > BoltImportSymbol {
  name: BoltQualName,
}

node BoltImportDirective > BoltSourceElement {
  modifiers: BoltModifiers,
  file: String,
  symbols: Vec<BoltImportSymbol>,
}

node BoltExportSymbol;

node BoltPlainExportSymbol {
  name: BoltQualName,
}

node BoltExportDirective > BoltSourceElement {
  file: String,
  symbols: Option<Vec<BoltExportSymbol>>,
}

node BoltTraitDeclaration > BoltDeclaration, BoltTypeDeclaration {
  modifiers: BoltModifiers,
  name: BoltIdentifier,
  typeParams: Option<Vec<BoltTypeParameter>>,
  elements: Vec<BoltDeclaration>,
}

node BoltImplDeclaration > BoltDeclaration {
  modifiers: BoltModifiers,
  name: BoltIdentifier,
  trait: BoltTypeExpression,
  typeParams: Option<Vec<BoltTypeParameter>>,
  elements: Vec<BoltDeclaration>,
}

node BoltTypeAliasDeclaration > BoltDeclaration, BoltTypeDeclaration {
  modifiers: BoltModifiers,
  name: BoltIdentifier,
  typeParams: Option<Vec<BoltTypeParameter>>,
  typeExpr: BoltTypeExpression,
}

node BoltRecordMember;

node BoltRecordField > BoltRecordMember {
  name: BoltIdentifier,
  type: BoltTypeExpression,
}

node BoltRecordDeclaration > BoltDeclaration, BoltTypeDeclaration {
  modifiers: BoltModifiers,
  name: BoltIdentifier,
  typeParms: Option<Vec<BoltTypeParameter>>,
  members: Option<Vec<BoltRecordMember>>,
}

node BoltSourceElement;

node BoltMacroCall > BoltRecordMember, BoltStatement, BoltDeclaration, BoltExpression {
  name: BoltIdentifier,
  text: String,
}

// JavaScript AST definitions

type JSValue = Int | String | Bool | Void;

node JSToken > Token;

node JSOperator > JSToken {
  text: String,
}

node JSIdentifier > JSToken {
  text: String,
}

node JSString > JSToken {
  value: String,
}

node JSInteger > JSToken {
  value: Int,
}

node JSFromKeyword > JSToken;
node JSReturnKeyword > JSToken;
node JSTryKeyword > JSToken;
node JSFinallyKeyword > JSToken;
node JSCatchKeyword > JSToken;
node JSImportKeyword > JSToken;
node JSAsKeyword > JSToken;
node JSConstKeyword > JSToken;
node JSLetKeyword > JSToken;
node JSExportKeyword > JSToken;
node JSFunctionKeyword > JSToken;
node JSWhileKeyword > JSToken;
node JSForKeyword > JSToken;

node JSCloseBrace > JSToken;
node JSCloseBracket > JSToken;
node JSCloseParen > JSToken;
node JSOpenBrace > JSToken;
node JSOpenBracket > JSToken;
node JSOpenParen > JSToken;
node JSSemi > JSToken;
node JSComma > JSToken;
node JSDot > JSToken;
node JSDotDotDot > JSToken;
node JSMulOp > JSToken;
node JSAddOp > JSToken;
node JSDivOp > JSToken;
node JSSubOp > JSToken;
node JSLtOp > JSToken;
node JSGtOp > JSToken;
node JSBOrOp > JSToken;
node JSBXorOp > JSToken;
node JSBAndOp > JSToken;
node JSBNotOp > JSToken;
node JSNotOp > JSToken;

node JSPattern;

node JSBindPattern > JSPattern {
  name: JSIdentifier,
}

node JSExpression;

node JSConstantExpression > JSExpression {
  value: BoltValue,
}

node JSMemberExpression > JSExpression {
  value: JSExpression,
  property: JSIdentifier,
}

node JSCallExpression > JSExpression {
  operator: JSExpression,
  operands: Vec<JSExpression>,
}

node JSBinaryExpression > JSExpression {
  left: JSExpression,
  operator: JSOperator,
  right: JSExpression,
}

node JSUnaryExpression > JSExpression {
  operator: JSOperator,
  operand: JSExpression
}

node JSNewExpression > JSExpression {
  target: JSExpression,
  arguments: Vec<JSExpression>,
}

node JSSequenceExpression > JSExpression {
  expressions: Vec<JSExpression>,
}

node JSConditionalExpression > JSExpression {
  test: JSExpression,
  consequent: JSExpression,
  alternate: JSExpression,
}

type JSValue = Int

node JSLiteralExpression > JSExpression {
  value: JSValue,
}

node JSReferenceExpression > JSExpression {
  name: String,
}

node JSSourceElement;

node JSFunctionBodyElement;

node JSStatement > JSSourceElement, JSFunctionBodyElement;

node JSCatchBlock {
  bindings: Option<JSPattern>,
  elements: Vec<JSSourceElement>,
}

node JSTryCatchStatement {
  tryBlock: Vec<JSSourceElement>,
  catchBlock: Option<JSCatchBlock>,
  finalBlock: Option<Vec<JSSourceElement>>,
}

node JSExpressionStatement > JSStatement {
  expression: JSExpression,
}

node JSConditionalCase {
  test: Option<JSExpression>,
  body: Vec<JSFunctionBodyElement>,
}

node JSConditionalStatement > JSStatement {
  cases: Vec<JSConditionalCase>,
}

node JSReturnStatement > JSStatement {
  value: Option<JSExpression>,
}

node JSParameter {
  index: usize,
  bindings: JSPattern,
  defaultValue: Option<JSExpression>,
}

node JSDeclaration > JSSourceElement;

enum JSDeclarationModifiers {
  IsExported = 0x1,
}

node JSImportBinding;

node JSImportStarBinding > JSImportBinding {
  local: JSIdentifier,
}

node JSImportAsBinding > JSImportBinding {
  remote: JSIdentifier,
  local: Option<JSIdentifier>,
}

node JSImportDeclaration > JSDeclaration {
  bindings: Vec<JSImportBinding>,
  filename: JSString,
}

node JSFunctionDeclaration > JSDeclaration, JSFunctionBodyElement {
  modifiers: JSDeclarationModifiers,
  name: JSIdentifier,
  params: Vec<JSParameter>,
  body: Vec<JSStatement>,
}

node JSArrowFunctionDeclaration > JSDeclaration, JSFunctionBodyElement {
  name: JSIdentifier,
  params: Vec<JSParameter>,
  body: JSExpression,
}

node JSLetDeclaration > JSDeclaration, JSFunctionBodyElement {
  bindings: JSPattern,
  value: Option<JSExpression>,
}

node JSSourceFile > SourceFile {
  elements: Vec<JSSourceElement>,
}

